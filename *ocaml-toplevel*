        OCaml version 4.02.3

#use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)




(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;



(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


(*
test_string xHexChar "xa";; 
*)
let hexParser =  
  (*let _zeroPrefix = char '0' in *)
  let _xPrefix = char_ci 'x' in
  let _hexNumbers = range '0' '9' in
  let _hexSmallLetters = range 'a' 'f' in
  let _hexCapsLetters = range 'A' 'F' in
  let _hexDigitsWrapper = disj_list [_hexNumbers; _hexSmallLetters; _hexCapsLetters] in 

  (* TODO add star *)
  let _hexDigitsWrapperStar = star (_hexDigitsWrapper) in 

  let _wrapper = caten_list [_xPrefix; _hexDigitsWrapper] in
  pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#                   Characters 212-213:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     Characters 35-47:
  let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
                                   ^^^^^^^^^^^^
Error: Unbound value returnParser
#         Characters 54-70:
    let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                                      ^^^^^^^^^^^^^^^^
Error: Unbound value charPrefixParser
#     Characters 35-51:
  test_string charPrefixParser "#\\";;
              ^^^^^^^^^^^^^^^^
Error: Unbound value charPrefixParser
#             val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     * *                           Characters 540-541:
    pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
                                                                 ^
Error: This expression has type char list
       but an expression was expected of type char
# test_string charPrefixParser "#\\";;
Characters 12-28:
  test_string charPrefixParser "#\\";;
              ^^^^^^^^^^^^^^^^
Error: Unbound value charPrefixParser
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;



(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


(*
test_string xHexChar "xa";; 
*)
let hexParser =  
  (*let _zeroPrefix = char '0' in *)
  let _xPrefix = char_ci 'x' in
  let _hexNumbers = range '0' '9' in
  let _hexSmallLetters = range 'a' 'f' in
  let _hexCapsLetters = range 'A' 'F' in
  let _hexDigitsWrapper = disj_list [_hexNumbers; _hexSmallLetters; _hexCapsLetters] in 

  (* TODO add star *)
  let _hexDigitsWrapperStar = star (_hexDigitsWrapper) in 

  let _wrapper = caten_list [_xPrefix; _hexDigitsWrapper] in
  pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               Characters 210-211:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         Characters 54-70:
    let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                                      ^^^^^^^^^^^^^^^^
Error: Unbound value charPrefixParser
#     Characters 35-51:
  test_string charPrefixParser "#\\";;
              ^^^^^^^^^^^^^^^^
Error: Unbound value charPrefixParser
#             val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     * *                           Characters 540-541:
    pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
                                                                 ^
Error: This expression has type char list
       but an expression was expected of type char
# let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;
      Characters 163-164:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
# let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;
      val charPrefixParser : char list -> string * char list = <fun>
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;



(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


(*
test_string xHexChar "xa";; 
*)
let hexParser =  
  (*let _zeroPrefix = char '0' in *)
  let _xPrefix = char_ci 'x' in
  let _hexNumbers = range '0' '9' in
  let _hexSmallLetters = range 'a' 'f' in
  let _hexCapsLetters = range 'A' 'F' in
  let _hexDigitsWrapper = disj_list [_hexNumbers; _hexSmallLetters; _hexCapsLetters] in 

  (* TODO add star *)
  let _hexDigitsWrapperStar = star (_hexDigitsWrapper) in 

  let _wrapper = caten_list [_xPrefix; _hexDigitsWrapper] in
  pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[]")
#             val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     * *                           Characters 540-541:
    pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
                                                                 ^
Error: This expression has type char list
       but an expression was expected of type char
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[]")
# let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;
      Characters 163-164:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               Characters 210-211:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               Characters 210-211:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               Characters 210-211:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("#\\", "->[a]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Characters 48-50:
  test_string charParser "#\a";;
                           ^^
Warning 14: illegal backslash escape in string.
Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> "#\\");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x  -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               Characters 210-211:
    pack _charPrefixParser (fun x  -> '#\');;
                                      ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> '#\');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               Characters 209-210:
    pack _charPrefixParser (fun x -> '#\');;
                                     ^
Error: Syntax error: operator expected.
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char ('#');;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> '#');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix ] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> char * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> '#');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> char * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# test_string charPrefixParser "\\";;
Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> '#');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> char * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> '#');;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> char * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : char * string = ('#', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charPrefixParser "#\\";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : string * string = ("", "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string visibleSimpleCharPrefix "a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     - : char * string = ('a', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj_list[caten charPrefixParser namedCharParser ;
                              caten charPrefixParser visibleSimpleCharPrefix] in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#         val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#     Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj namedCharParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> l);;

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#   Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser  namedCharParser in
  pack charAsList (fun l -> l);;

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#   Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser  visibleSimpleCharPrefix in
  pack charAsList (fun l -> l);;

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#   - : (string * char) * string = (("", 'a'), "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser  visibleSimpleCharPrefix in
  pack charAsList (fun l -> snd l);;

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> char * char list = <fun>
#   - : char * string = ('a', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l -> snd l);;

test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> char * char list = <fun>
#   - : char * string = ('a', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l -> snd l);;

test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
#       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> char * char list = <fun>
#   - : char * string = ('s', "->[pace]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;

test_string charParser "#\\space";;



(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


(*
test_string xHexChar "xa";; 
*)
let hexParser =  
  (*let _zeroPrefix = char '0' in *)
  let _xPrefix = char_ci 'x' in
  let _hexNumbers = range '0' '9' in
  let _hexSmallLetters = range 'a' 'f' in
  let _hexCapsLetters = range 'A' 'F' in
  let _hexDigitsWrapper = disj_list [_hexNumbers; _hexSmallLetters; _hexCapsLetters] in 

  (* TODO add star *)
  let _hexDigitsWrapperStar = star (_hexDigitsWrapper) in 

  let _wrapper = caten_list [_xPrefix; _hexDigitsWrapper] in
  pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#   - : (string * char) * string = (("", 's'), "->[pace]")
#             val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     * *                           Characters 540-541:
    pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
                                                                 ^
Error: This expression has type char list
       but an expression was expected of type char
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;

test_string charParser "#\\space";;



(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#   - : (string * char) * string = (("", 's'), "->[pace]")
#             val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;

test_string charParser "#\\space";;



(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#   - : (string * char) * string = (("", 's'), "->[pace]")
#             val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;






test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#             - : (string * char) * string = (("", 's'), "->[pace]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;






test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#             - : (string * char) * string = (("", 's'), "->[pace]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)



let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #           val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

test_string charParser "#\\space";;


let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       - : (string * char) * string = (("", 's'), "->[pace]")
#     val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
# 



















































#use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

test_string charParser "#\\space";;


let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;
(*
let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)
*)

let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       - : (string * char) * string = (("", 's'), "->[pace]")
#     val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
# * * * * * * *         val charParser : char list -> (string * char) * char list = <fun>
#                                                                                                         #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

test_string charParser "#\\space";;


let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       - : (string * char) * string = (("", 's'), "->[pace]")
#     val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
# 









#use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

(*
let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;
*)


test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#     * * * *       - : char * string = (' ', "->[]")
#                     #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

(*
let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;
*)


test_string charParser "#\\return";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#     * * * *       - : char * string = ('\r', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

test_string charParser "#\\space";;


let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       - : char * string = (' ', "->[]")
#     val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)

(*
let charParser =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;
*)



test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#     * * * *         - : char * string = (' ', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


let charParser2 =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;




test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#           val charParser2 : char list -> (string * char) * char list = <fun>
#         - : char * string = (' ', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


let charParser2 =
  let charAsList =  caten charPrefixParser (disj visibleSimpleCharPrefix namedCharParser) in
  pack charAsList (fun l ->l);;




test_string charParser2 "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#           val charParser2 : char list -> (string * char) * char list = <fun>
#         - : (string * char) * string = (("", 's'), "->[pace]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


let charParser2 =
  let charAsList =  caten charPrefixParser (disj namedCharParser visibleSimpleCharPrefix) in
  pack charAsList (fun l ->l);;




test_string charParser2 "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#           val charParser2 : char list -> (string * char) * char list = <fun>
#         - : (string * char) * string = (("", ' '), "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


test_string charParser2 "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#       - : (string * char) * string = (("", ' '), "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


test_string charParser2 "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#       - : (string * char) * string = (("", ' '), "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


test_string charParser2 "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#       - : (string * char) * string = (("", ' '), "->[]")
# test_string charParser2 "#\\space";;
- : (string * char) * string = (("", ' '), "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


test_string charParser "#\\space";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#       - : char * string = (' ', "->[]")
# test_string charParser "#\\space";;
- : char * string = (' ', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


test_string charParser "#\\a";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#       - : char * string = ('a', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> snd l);;
(* end char parser *)


test_string charParser "#\\r";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> char * char list = <fun>
#       - : char * string = ('r', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string charParser "#\\r";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       - : sexpr * string = (Char 'r', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Chara (snd l));;
(* end char parser *)


test_string charParser "#\\r";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           Characters 172-177:
    pack charAsList (fun l -> Chara (snd l));;
                              ^^^^^
Error: Unbound constructor Chara
Hint: Did you mean Char?
#       - : sexpr * string = (Char 'r', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> char (snd l));;
(* end char parser *)


test_string charParser "#\\r";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> (char list -> char * char list) * char list =
  <fun>
#       - : (char list -> char * char list) * string = (<fun>, "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string charParser "#\\r";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> bool * char list = <fun>
#         val falseParser : char list -> bool * char list = <fun>
#   val booleanParser : char list -> bool * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       - : sexpr * string = (Char 'r', "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool (true));;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool (false));;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string booleanParser "#\\r";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> sexpr * char list = <fun>
#         val falseParser : char list -> sexpr * char list = <fun>
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool (true));;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool (false));;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string booleanParser "#t";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> sexpr * char list = <fun>
#         val falseParser : char list -> sexpr * char list = <fun>
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       - : sexpr * string = (Bool true, "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool ("true"));;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool ("false"));;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string booleanParser "#t";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             Characters 167-175:
    pack _hashT_ (fun x -> Bool ("true"));;
                                ^^^^^^^^
Error: This expression has type string but an expression was expected of type
         bool
#         Characters 119-128:
    pack _hashF_ (fun x -> Bool ("false"));;
                                ^^^^^^^^^
Error: This expression has type string but an expression was expected of type
         bool
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool ("true"));;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool ("false"));;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string booleanParser "#t";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             Characters 167-175:
    pack _hashT_ (fun x -> Bool ("true"));;
                                ^^^^^^^^
Error: This expression has type string but an expression was expected of type
         bool
#         Characters 119-128:
    pack _hashF_ (fun x -> Bool ("false"));;
                                ^^^^^^^^^
Error: This expression has type string but an expression was expected of type
         bool
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       Exception: PC.X_no_match.
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string booleanParser "#t";;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> sexpr * char list = <fun>
#         val falseParser : char list -> sexpr * char list = <fun>
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       - : sexpr * string = (Bool true, "->[]")
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)


test_string booleanParser "#t";;








let hexParser =  
  (*let _zeroPrefix = char '0' in *)
  let _xPrefix = char_ci 'x' in
  let _hexNumbers = range '0' '9' in
  let _hexSmallLetters = range 'a' 'f' in
  let _hexCapsLetters = range 'A' 'F' in
  let _hexDigitsWrapper = disj_list [_hexNumbers; _hexSmallLetters; _hexCapsLetters] in 

  (* TODO add star *)
  let _hexDigitsWrapperStar = star (_hexDigitsWrapper) in 

  let _wrapper = caten_list [_xPrefix; _hexDigitsWrapper] in
  pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> sexpr * char list = <fun>
#         val falseParser : char list -> sexpr * char list = <fun>
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#       - : sexpr * string = (Bool true, "->[]")
#                                         Characters 511-512:
    pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
                                                                 ^
Error: This expression has type char list
       but an expression was expected of type char
# #use "pc.ml";;
#use "reader.ml";;
open PC;;

(*service function *)

let spaces = star (char ' ');;

let hashtagParser = char '#';;
(* end service function *)

(*boolean function *)
let trueParser =
  let _t_ = char_ci 't' in
  let _hashT_ = caten hashtagParser _t_ in
  pack _hashT_ (fun x -> Bool true);;

let falseParser =
  let _f_ = char_ci 'f' in
  let _hashF_ = caten hashtagParser _f_ in
  pack _hashF_ (fun x -> Bool false);;

let booleanParser = disj falseParser trueParser;; 
(* end boolean function *)


(* char parser *)
let charPrefixParser =
  let backslashParser = char '\\' in
  let _charPrefixParser =   caten hashtagParser backslashParser in
  pack _charPrefixParser (fun x -> "");;

let visibleSimpleCharPrefix =
  let simpleCharParser = const (fun ch -> ch > ' ') in
  pack simpleCharParser (fun x -> x);;


(* named Char parsers *)
let newLineParser =
  let _newLineParser = word_ci "newline" in
  pack _newLineParser (fun nch -> Char.chr(10));;

let returnParser =
  let _returnParser  = word_ci "return" in
  pack _returnParser (fun nch -> Char.chr(13));;
 
let tabParser =
  let _tabParser = word_ci "tab" in
  pack _tabParser (fun nch -> Char.chr(9));;

let pageParser =
  let _pageParser = word_ci "page" in
  pack _pageParser (fun nch -> Char.chr(12));;

let nulParser =
  let _nulParser = word_ci "nul" in
  pack _nulParser (fun nch -> Char.chr(0));;

let spaceParser =
  let _spaceParser = word_ci "space" in
  pack _spaceParser (fun nch -> Char.chr(32));;


let namedCharParser = disj_list [returnParser; newLineParser; tabParser; pageParser; nulParser; spaceParser];;

let charParser =
  let charAsList =  disj
    (caten charPrefixParser namedCharParser)
    (caten charPrefixParser visibleSimpleCharPrefix) in
  pack charAsList (fun l -> Char (snd l));;
(* end char parser *)



(* Boolean test () *)

(*
test_string booleanParser "#t";;
*)



let hexParser =  
  (*let _zeroPrefix = char '0' in *)
  let _xPrefix = char_ci 'x' in
  let _hexNumbers = range '0' '9' in
  let _hexSmallLetters = range 'a' 'f' in
  let _hexCapsLetters = range 'A' 'F' in
  let _hexDigitsWrapper = disj_list [_hexNumbers; _hexSmallLetters; _hexCapsLetters] in 

  (* TODO add star *)
  let _hexDigitsWrapperStar = star (_hexDigitsWrapper) in 

  let _wrapper = caten_list [_xPrefix; _hexDigitsWrapper] in
  pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
# val ormap : ('a -> bool) -> 'a list -> bool = <fun>
val andmap : ('a -> bool) -> 'a list -> bool = <fun>
val lowercase_ascii : char -> char = <fun>
val string_to_list : string -> char list = <fun>
val list_to_string : char list -> string = <fun>
module PC :
  sig
    exception X_not_yet_implemented
    exception X_no_match
    val const : ('a -> bool) -> 'a list -> 'a * 'a list
    val caten : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e
    val pack : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c
    val nt_epsilon : 'a -> 'b list * 'a
    val caten_list : ('a -> 'b * 'a) list -> 'a -> 'b list * 'a
    val disj : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b
    val nt_none : 'a -> 'b
    val disj_list : ('a -> 'b) list -> 'a -> 'b
    val delayed : (unit -> 'a -> 'b) -> 'a -> 'b
    val nt_end_of_input : 'a list -> 'b list * 'c list
    val star : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val plus : ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val guard : ('a -> 'b * 'c) -> ('b -> bool) -> 'a -> 'b * 'c
    val diff : ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b
    val not_followed_by : ('a -> 'b * 'c) -> ('c -> 'd) -> 'a -> 'b * 'c
    val maybe : ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val make_char : ('a -> 'b -> bool) -> 'a -> 'b list -> 'b * 'b list
    val char : char -> char list -> char * char list
    val char_ci : char -> char list -> char * char list
    val make_word : (char -> 'a -> 'b * 'a) -> string -> 'a -> 'b list * 'a
    val word : string -> char list -> char list * char list
    val word_ci : string -> char list -> char list * char list
    val make_one_of : (char -> 'a -> 'b) -> string -> 'a -> 'b
    val one_of : string -> char list -> char * char list
    val one_of_ci : string -> char list -> char * char list
    val nt_whitespace : char list -> char * char list
    val make_range :
      (char -> char -> bool) -> char -> char -> char list -> char * char list
    val range : char -> char -> char list -> char * char list
    val range_ci : char -> char -> char list -> char * char list
    val nt_any : char list -> char * char list
    val trace_pc :
      string -> (char list -> 'a * char list) -> char list -> 'a * char list
    val test_string : (char list -> 'a * char list) -> string -> 'a * string
  end
exception X_not_yet_implemented
exception X_this_should_not_happen
type number = Int of int | Float of float
type sexpr =
    Bool of bool
  | Nil
  | Number of number
  | Char of char
  | String of string
  | Symbol of string
  | Pair of sexpr * sexpr
  | Vector of sexpr list
val sexpr_eq : sexpr -> sexpr -> bool = <fun>
module Reader :
  sig
    val read_sexpr : string -> sexpr
    val read_sexprs : string -> sexpr list
  end
# #       val spaces : char list -> char list * char list = <fun>
#   val hashtagParser : char list -> char * char list = <fun>
#             val trueParser : char list -> sexpr * char list = <fun>
#         val falseParser : char list -> sexpr * char list = <fun>
#   val booleanParser : char list -> sexpr * char list = <fun>
#               val charPrefixParser : char list -> string * char list = <fun>
#       val visibleSimpleCharPrefix : char list -> char * char list = <fun>
#           val newLineParser : char list -> char * char list = <fun>
#       val returnParser : char list -> char * char list = <fun>
#       val tabParser : char list -> char * char list = <fun>
#       val pageParser : char list -> char * char list = <fun>
#       val nulParser : char list -> char * char list = <fun>
#       val spaceParser : char list -> char * char list = <fun>
#     val namedCharParser : char list -> char * char list = <fun>
#           val charParser : char list -> sexpr * char list = <fun>
#             * *                                 Characters 593-594:
    pack _wrapper (fun x -> int_of_string (list_to_string (['0'; x])));;
                                                                 ^
Error: This expression has type char list
       but an expression was expected of type char
# 